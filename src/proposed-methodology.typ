= Proposed Methodology

Based on the problem analysis, the proposed solution is to develop a crypto-ransomware program, which consists of two separate programs: an encryptor and a decryptor. The development tools for both programs will include the C++ programming language, Visual Studio Code as the text editor, the Windows operating system running inside a kernel-based virtual machine, and a variety of antivirus software for testing purposes.

Development of the encryptor begins with creating a program that evades static detection by antivirus software, as well as dynamic detection before the encryption stage begins. The techniques used include code obfuscation and dynamic invocation of Windows API functions. Code obfuscation will be applied by encrypting strings at compile time and decrypting them at runtime to prevent static string analysis, along with adding junk instructions or unused code to hinder reverse engineering. Required DLL files will be loaded dynamically by reading the GS segment value at offset 0x60, which contains the address of the Process Environment Block (PEB). Inside the PEB is another structure, PEB_LDR_DATA, which stores the list of modules (DLLs) already loaded by the process. This allows the program to locate the address of specific functions or modules without explicitly calling LoadLibraryA. The target function to be invoked will be identified by matching the hash value of its name against the hashed names of functions inside the DLL, one by one. This technique helps bypass certain API hooking methods. These approaches are adapted from techniques used by real-world ransomware to improve static evasion capabilities.

A baseline version of the program will first be developed using the simplest possible approach as a reference point for measuring improvements. Then, multiple categories of encryption techniques will be implemented, with each category containing several variants. At runtime, one technique from each category can be selected and combined, allowing evaluation of different combinations against various antivirus products. The four planned categories are:

+ Number of encryption threads - options: 1, 2, 4, 8, or 16 worker threads. The assumption is that more threads will produce more suspicious file changes over a short period, increasing the likelihood of detection by behavioral analysis, while also speeding up encryption.

+ File opening and reading method - options: full read, stream-based read, or memory-mapped I/O. The assumption is that full reads appear more suspicious compared to more complex read methods, due to IRP logging and API monitoring by antivirus tools.

+ Encryption coverage percentage - options in increments of 10% up to 100%. The assumption is that higher coverage makes the program's behavior more suspicious to antivirus tools using IRP logging.

+ Encryption algorithm - options: Windows CryptoAPI or a manually implemented AES algorithm. The assumption is that using CryptoAPI appears more suspicious to antivirus software due to API monitoring detection techniques.

When executed, the program will read configuration parameters from argc and argv, locate the address of Kernel32.dll, and resolve required Windows API functions by hashing and matching function names. It will then spawn the specified number of threads, each operating on a pre-defined (hard-coded) target directory. Within each thread, the program will enumerate files in the directory and encrypt them. Encrypted files will be renamed with the .locked extension, and relevant information will be saved in a corresponding README file. Once all encryptable files have been processed, the program will terminate.

To ensure safety and prevent misuse, a decryptor will also be developed to restore encrypted files. Important details such as the algorithm and key used for each file will be stored in its README file. This guarantees that all encrypted data can be fully recovered in the testing environment. Therefore, while the program simulates the behavior of real-world ransomware, its implementation will remain secure, controlled, and unusable outside the research context.
