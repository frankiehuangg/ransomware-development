= Proposed Methodology

Based on the problem analysis, the proposed solution is to develop a crypto-ransomware program, which consists of two separate programs: an encryptor and a decryptor. The development tools for both programs will include the C++ programming language, Visual Studio Code as the text editor, the Windows operating system running inside a kernel-based virtual machine, and a variety of antivirus software for testing purposes.

Development of the encryptor begins with creating a program that evades static detection by antivirus software, as well as dynamic detection before the encryption stage begins using approaches used by real-world ransomwares.

A baseline version of the program will first be developed using the simplest possible approach as a reference point for measuring improvements. Then, multiple categories of encryption techniques will be implemented, with each category containing several variants. At runtime, one technique from each category can be selected and combined, allowing evaluation of different combinations against various antivirus products. The four planned categories are:

+ Number of encryption threads - options: 1, 2, 4, 8, or 16 worker threads. The assumption is that more threads will produce more suspicious file changes over a short period, increasing the likelihood of detection by behavioral analysis, while also speeding up encryption.

+ File opening and reading method - options: full read, stream-based read, or memory-mapped I/O. The assumption is that full reads appear more suspicious compared to more complex read methods, due to IRP logging and API monitoring by antivirus tools.

+ Encryption coverage percentage - options in increments of 10% up to 100%. The assumption is that higher coverage makes the program's behavior more suspicious to antivirus tools using IRP logging.

+ Encryption algorithm - options: Windows CryptoAPI or a manually implemented AES algorithm. The assumption is that using CryptoAPI appears more suspicious to antivirus software due to API monitoring detection techniques.

When executed, the program will read configuration parameters from argc and argv, locate the address of Kernel32.dll, and resolve required Windows API functions by hashing and matching function names. It will then spawn the specified number of threads, each operating on a pre-defined (hard-coded) target directory. Within each thread, the program will enumerate files in the directory and encrypt them. Encrypted files will be renamed with the .locked extension, and relevant information will be saved in a corresponding README file. Once all encryptable files have been processed, the program will terminate.

To ensure safety and prevent misuse, a decryptor will also be developed to restore encrypted files. Important details such as the algorithm and key used for each file will be stored in its README file. This guarantees that all encrypted data can be fully recovered in the testing environment. Therefore, while the program simulates the behavior of real-world ransomware, its implementation will remain secure, controlled, and unusable outside the research context, by trading off the fact that it may not capture every nuance of ransomware and crypto ransomware attack lifecycle.

To ensure safety and prevent misuse, a dedicated decryptor will be developed to restore all encrypted files within the test environment. For every sample, essential details such as the encryption algorithm, key, and recovery procedure will be recorded in an accompanying README file. This guarantees that all encrypted data can be fully recovered and that no irreversible damage occurs during experimentation. Consequently, while the program accurately reproduces the operational behavior of real-world ransomware, its implementation remains secure, isolated, and non-transferable beyond the research context. This controlled design inherently involves a trade-off: although it limits ecological realism by not replicating every aspect of the ransomware or crypto-ransomware attack lifecycle, it ensures complete experimental safety and ethical compliance. To prevent misuse, no executable binaries will be shared publicly to prevent misuse, and no real-world malware, sensitive data, live networks or systems were involved at any stages.
